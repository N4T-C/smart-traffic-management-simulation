{"file_contents":{"PROMPTS.md":{"content":"PROMPTS:\n\n#1\n\n\n#2\n\n\n#3\n\n\n","size_bytes":25},"README.md":{"content":"# smart-traffic-management-simulation\nFor the Smart India Hackathon!\n\n\n\n\n\n","size_bytes":74},"backend/flask_app/app.py":{"content":"\"\"\"\nSmart Traffic Management Simulation - Main Application\nPygame-based traffic simulation with AI traffic light control\n\"\"\"\n\nimport pygame\nimport random\nimport sys\nimport time\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport math\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nSCREEN_WIDTH = 1200\nSCREEN_HEIGHT = 800\nFPS = 60\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nGRAY = (128, 128, 128)\nDARK_GRAY = (64, 64, 64)\nORANGE = (255, 165, 0)\nPURPLE = (128, 0, 128)\n\n# Traffic light states\nclass LightState(Enum):\n    RED = \"RED\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\nclass Direction(Enum):\n    NORTH = 0\n    EAST = 1\n    SOUTH = 2\n    WEST = 3\n\n@dataclass\nclass Vehicle:\n    x: float\n    y: float\n    direction: Direction\n    speed: float\n    is_emergency: bool = False\n    color: tuple = BLUE\n    width: int = 30\n    height: int = 15\n    \n    def __post_init__(self):\n        if self.is_emergency:\n            self.color = RED\n            self.speed *= 1.2  # Emergency vehicles move slightly faster\n\nclass TrafficLight:\n    def __init__(self, direction: Direction, x: int, y: int):\n        self.direction = direction\n        self.state = LightState.RED\n        self.x = x\n        self.y = y\n        self.timer = 0\n        self.green_duration = 5000  # milliseconds\n        self.yellow_duration = 2000\n        self.red_duration = 3000\n        \n    def update(self, dt: int, vehicle_count: int, emergency_present: bool):\n        \"\"\"Update traffic light state based on conditions\"\"\"\n        # Emergency vehicle overrides normal operation\n        if emergency_present and self.state != LightState.GREEN:\n            self.state = LightState.GREEN\n            self.timer = 0\n            return\n            \n        self.timer += dt\n        \n        # Dynamic green duration based on vehicle count\n        dynamic_green = max(3000, min(10000, vehicle_count * 1000))\n        \n        if self.state == LightState.GREEN:\n            if self.timer >= dynamic_green:\n                self.state = LightState.YELLOW\n                self.timer = 0\n        elif self.state == LightState.YELLOW:\n            if self.timer >= self.yellow_duration:\n                self.state = LightState.RED\n                self.timer = 0\n        elif self.state == LightState.RED:\n            if self.timer >= self.red_duration:\n                self.state = LightState.GREEN\n                self.timer = 0\n    \n    def get_color(self):\n        return {\n            LightState.RED: RED,\n            LightState.YELLOW: YELLOW,\n            LightState.GREEN: GREEN\n        }[self.state]\n\nclass TrafficSimulation:\n    def __init__(self):\n        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\n        pygame.display.set_caption(\"Smart AI Traffic Light System\")\n        self.clock = pygame.time.Clock()\n        self.font = pygame.font.Font(None, 36)\n        self.small_font = pygame.font.Font(None, 24)\n        \n        # Initialize traffic lights\n        center_x, center_y = SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2\n        self.traffic_lights = {\n            Direction.NORTH: TrafficLight(Direction.NORTH, center_x - 50, center_y - 100),\n            Direction.EAST: TrafficLight(Direction.EAST, center_x + 50, center_y - 50),\n            Direction.SOUTH: TrafficLight(Direction.SOUTH, center_x + 50, center_y + 100),\n            Direction.WEST: TrafficLight(Direction.WEST, center_x - 50, center_y + 50)\n        }\n        \n        # Initialize vehicles\n        self.vehicles: Dict[Direction, List[Vehicle]] = {\n            Direction.NORTH: [],\n            Direction.EAST: [],\n            Direction.SOUTH: [],\n            Direction.WEST: []\n        }\n        \n        # Timing\n        self.last_vehicle_spawn = {direction: 0 for direction in Direction}\n        self.current_green_lane = Direction.NORTH\n        self.emergency_cooldown = 0\n        \n        # Stats\n        self.stats = {\n            'total_vehicles': 0,\n            'vehicles_passed': 0,\n            'emergency_activations': 0,\n            'avg_wait_time': 0\n        }\n        \n        # Set initial green light\n        self.traffic_lights[Direction.NORTH].state = LightState.GREEN\n        \n    def spawn_vehicle(self, direction: Direction):\n        \"\"\"Spawn a new vehicle in the specified direction\"\"\"\n        current_time = pygame.time.get_ticks()\n        \n        # Control spawn rate\n        if current_time - self.last_vehicle_spawn[direction] < random.randint(1000, 3000):\n            return\n            \n        self.last_vehicle_spawn[direction] = current_time\n        \n        # 5% chance of emergency vehicle\n        is_emergency = random.random() < 0.05\n        speed = random.uniform(1, 3)\n        \n        if direction == Direction.NORTH:\n            vehicle = Vehicle(SCREEN_WIDTH // 2 - 15, SCREEN_HEIGHT - 50, direction, speed, is_emergency)\n        elif direction == Direction.EAST:\n            vehicle = Vehicle(50, SCREEN_HEIGHT // 2 - 15, direction, speed, is_emergency)\n        elif direction == Direction.SOUTH:\n            vehicle = Vehicle(SCREEN_WIDTH // 2 + 15, 50, direction, speed, is_emergency)\n        else:  # WEST\n            vehicle = Vehicle(SCREEN_WIDTH - 50, SCREEN_HEIGHT // 2 + 15, direction, speed, is_emergency)\n            \n        self.vehicles[direction].append(vehicle)\n        self.stats['total_vehicles'] += 1\n        \n        if is_emergency:\n            self.stats['emergency_activations'] += 1\n    \n    def update_vehicles(self, dt: int):\n        \"\"\"Update all vehicle positions and handle traffic light logic\"\"\"\n        center_x, center_y = SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2\n        stop_distance = 80  # Distance from center to stop\n        \n        for direction, vehicle_list in self.vehicles.items():\n            light = self.traffic_lights[direction]\n            emergency_in_lane = any(v.is_emergency for v in vehicle_list)\n            \n            # Update traffic light\n            light.update(dt, len(vehicle_list), emergency_in_lane)\n            \n            for vehicle in vehicle_list[:]:  # Copy list to avoid modification issues\n                should_stop = False\n                \n                # Check if vehicle should stop at red/yellow light\n                if light.state in [LightState.RED, LightState.YELLOW]:\n                    if direction == Direction.NORTH and vehicle.y > center_y + stop_distance:\n                        should_stop = True\n                    elif direction == Direction.EAST and vehicle.x < center_x - stop_distance:\n                        should_stop = True\n                    elif direction == Direction.SOUTH and vehicle.y < center_y - stop_distance:\n                        should_stop = True\n                    elif direction == Direction.WEST and vehicle.x > center_x + stop_distance:\n                        should_stop = True\n                \n                # Move vehicle if not stopping\n                if not should_stop:\n                    if direction == Direction.NORTH:\n                        vehicle.y -= vehicle.speed\n                    elif direction == Direction.EAST:\n                        vehicle.x += vehicle.speed\n                    elif direction == Direction.SOUTH:\n                        vehicle.y += vehicle.speed\n                    else:  # WEST\n                        vehicle.x -= vehicle.speed\n                \n                # Remove vehicles that have passed through\n                if (direction == Direction.NORTH and vehicle.y < -50) or \\\n                   (direction == Direction.EAST and vehicle.x > SCREEN_WIDTH + 50) or \\\n                   (direction == Direction.SOUTH and vehicle.y > SCREEN_HEIGHT + 50) or \\\n                   (direction == Direction.WEST and vehicle.x < -50):\n                    vehicle_list.remove(vehicle)\n                    self.stats['vehicles_passed'] += 1\n    \n    def draw_road(self):\n        \"\"\"Draw the crossroad\"\"\"\n        center_x, center_y = SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2\n        road_width = 100\n        \n        # Draw roads\n        # Vertical road\n        pygame.draw.rect(self.screen, DARK_GRAY, \n                        (center_x - road_width//2, 0, road_width, SCREEN_HEIGHT))\n        # Horizontal road\n        pygame.draw.rect(self.screen, DARK_GRAY, \n                        (0, center_y - road_width//2, SCREEN_WIDTH, road_width))\n        \n        # Draw lane dividers\n        for i in range(0, SCREEN_HEIGHT, 40):\n            pygame.draw.rect(self.screen, WHITE, (center_x - 2, i, 4, 20))\n        for i in range(0, SCREEN_WIDTH, 40):\n            pygame.draw.rect(self.screen, WHITE, (i, center_y - 2, 20, 4))\n        \n        # Draw intersection\n        pygame.draw.rect(self.screen, GRAY, \n                        (center_x - road_width//2, center_y - road_width//2, \n                         road_width, road_width))\n    \n    def draw_traffic_lights(self):\n        \"\"\"Draw traffic lights\"\"\"\n        for light in self.traffic_lights.values():\n            # Light post\n            pygame.draw.rect(self.screen, BLACK, (light.x - 5, light.y - 20, 10, 40))\n            \n            # Light box\n            pygame.draw.rect(self.screen, BLACK, (light.x - 15, light.y - 15, 30, 30))\n            \n            # Light\n            pygame.draw.circle(self.screen, light.get_color(), (light.x, light.y), 12)\n            pygame.draw.circle(self.screen, BLACK, (light.x, light.y), 12, 2)\n    \n    def draw_vehicles(self):\n        \"\"\"Draw all vehicles\"\"\"\n        for vehicle_list in self.vehicles.values():\n            for vehicle in vehicle_list:\n                # Adjust vehicle size based on direction\n                if vehicle.direction in [Direction.NORTH, Direction.SOUTH]:\n                    width, height = vehicle.width, vehicle.height\n                else:\n                    width, height = vehicle.height, vehicle.width\n                \n                rect = pygame.Rect(vehicle.x - width//2, vehicle.y - height//2, width, height)\n                pygame.draw.rect(self.screen, vehicle.color, rect)\n                pygame.draw.rect(self.screen, BLACK, rect, 2)\n                \n                # Emergency vehicle indicator\n                if vehicle.is_emergency:\n                    pygame.draw.circle(self.screen, WHITE, \n                                     (int(vehicle.x), int(vehicle.y)), 5)\n    \n    def draw_ui(self):\n        \"\"\"Draw user interface with stats and information\"\"\"\n        # Background panel\n        pygame.draw.rect(self.screen, WHITE, (10, 10, 300, 200))\n        pygame.draw.rect(self.screen, BLACK, (10, 10, 300, 200), 2)\n        \n        y_offset = 30\n        \n        # Title\n        title = self.font.render(\"Traffic Control System\", True, BLACK)\n        self.screen.blit(title, (20, y_offset))\n        y_offset += 40\n        \n        # Vehicle counts\n        for i, (direction, vehicles) in enumerate(self.vehicles.items()):\n            count = len(vehicles)\n            emergency_count = sum(1 for v in vehicles if v.is_emergency)\n            light_state = self.traffic_lights[direction].state.value\n            \n            text = f\"{direction.name}: {count} cars\"\n            if emergency_count > 0:\n                text += f\" ({emergency_count} EMG)\"\n            text += f\" - {light_state}\"\n            \n            color = GREEN if light_state == \"GREEN\" else RED if light_state == \"RED\" else ORANGE\n            vehicle_text = self.small_font.render(text, True, color)\n            self.screen.blit(vehicle_text, (20, y_offset))\n            y_offset += 25\n        \n        # Current green lane\n        green_lanes = [d.name for d, light in self.traffic_lights.items() if light.state == LightState.GREEN]\n        green_text = f\"Green Lane: {', '.join(green_lanes) if green_lanes else 'None'}\"\n        green_surface = self.small_font.render(green_text, True, GREEN)\n        self.screen.blit(green_surface, (20, y_offset))\n        y_offset += 25\n        \n        # Stats panel\n        stats_bg = pygame.Rect(SCREEN_WIDTH - 220, 10, 200, 120)\n        pygame.draw.rect(self.screen, WHITE, stats_bg)\n        pygame.draw.rect(self.screen, BLACK, stats_bg, 2)\n        \n        stats_y = 30\n        stats_title = self.small_font.render(\"Statistics\", True, BLACK)\n        self.screen.blit(stats_title, (SCREEN_WIDTH - 210, stats_y))\n        stats_y += 30\n        \n        total_text = self.small_font.render(f\"Total Vehicles: {self.stats['total_vehicles']}\", True, BLACK)\n        self.screen.blit(total_text, (SCREEN_WIDTH - 210, stats_y))\n        stats_y += 20\n        \n        passed_text = self.small_font.render(f\"Vehicles Passed: {self.stats['vehicles_passed']}\", True, BLACK)\n        self.screen.blit(passed_text, (SCREEN_WIDTH - 210, stats_y))\n        stats_y += 20\n        \n        emergency_text = self.small_font.render(f\"Emergency Calls: {self.stats['emergency_activations']}\", True, BLACK)\n        self.screen.blit(emergency_text, (SCREEN_WIDTH - 210, stats_y))\n        \n        # Instructions\n        instructions = [\n            \"SPACE: Spawn emergency vehicle\",\n            \"1-4: Spawn vehicle in lane\",\n            \"ESC: Exit\"\n        ]\n        \n        for i, instruction in enumerate(instructions):\n            inst_text = self.small_font.render(instruction, True, BLACK)\n            self.screen.blit(inst_text, (20, SCREEN_HEIGHT - 80 + i * 20))\n    \n    def handle_events(self):\n        \"\"\"Handle pygame events\"\"\"\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                return False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_ESCAPE:\n                    return False\n                elif event.key == pygame.K_SPACE:\n                    # Spawn emergency vehicle in random lane\n                    direction = random.choice(list(Direction))\n                    self.spawn_emergency_vehicle(direction)\n                elif event.key == pygame.K_1:\n                    self.spawn_vehicle(Direction.NORTH)\n                elif event.key == pygame.K_2:\n                    self.spawn_vehicle(Direction.EAST)\n                elif event.key == pygame.K_3:\n                    self.spawn_vehicle(Direction.SOUTH)\n                elif event.key == pygame.K_4:\n                    self.spawn_vehicle(Direction.WEST)\n        return True\n    \n    def spawn_emergency_vehicle(self, direction: Direction):\n        \"\"\"Manually spawn an emergency vehicle\"\"\"\n        speed = random.uniform(2, 4)\n        \n        if direction == Direction.NORTH:\n            vehicle = Vehicle(SCREEN_WIDTH // 2 - 15, SCREEN_HEIGHT - 50, direction, speed, True)\n        elif direction == Direction.EAST:\n            vehicle = Vehicle(50, SCREEN_HEIGHT // 2 - 15, direction, speed, True)\n        elif direction == Direction.SOUTH:\n            vehicle = Vehicle(SCREEN_WIDTH // 2 + 15, 50, direction, speed, True)\n        else:  # WEST\n            vehicle = Vehicle(SCREEN_WIDTH - 50, SCREEN_HEIGHT // 2 + 15, direction, speed, True)\n            \n        self.vehicles[direction].append(vehicle)\n        self.stats['total_vehicles'] += 1\n        self.stats['emergency_activations'] += 1\n    \n    def run(self):\n        \"\"\"Main game loop\"\"\"\n        running = True\n        \n        while running:\n            dt = self.clock.tick(FPS)\n            \n            # Handle events\n            running = self.handle_events()\n            \n            # Randomly spawn vehicles\n            for direction in Direction:\n                if random.random() < 0.02:  # 2% chance per frame\n                    self.spawn_vehicle(direction)\n            \n            # Update simulation\n            self.update_vehicles(dt)\n            \n            # Draw everything\n            self.screen.fill(GREEN)  # Background (grass)\n            self.draw_road()\n            self.draw_traffic_lights()\n            self.draw_vehicles()\n            self.draw_ui()\n            \n            pygame.display.flip()\n        \n        pygame.quit()\n        sys.exit()\n\nif __name__ == \"__main__\":\n    simulation = TrafficSimulation()\n    simulation.run()","size_bytes":16126},"backend/flask_app/rl_agent.py":{"content":"\"\"\"\nReinforcement Learning Agent for Traffic Light Control\nThis module implements an RL agent that can learn optimal traffic light timing\n\"\"\"\n\nimport numpy as np\nimport random\nfrom typing import Dict, List, Tuple\nfrom enum import Enum\n\nclass ActionType(Enum):\n    EXTEND_GREEN = 0\n    SWITCH_TO_YELLOW = 1\n    EMERGENCY_OVERRIDE = 2\n\nclass TrafficRLAgent:\n    def __init__(self, learning_rate=0.1, discount_factor=0.95, epsilon=0.1):\n        \"\"\"\n        Initialize the RL agent for traffic control\n        \n        Args:\n            learning_rate: Learning rate for Q-learning\n            discount_factor: Discount factor for future rewards\n            epsilon: Exploration rate for epsilon-greedy policy\n        \"\"\"\n        self.learning_rate = learning_rate\n        self.discount_factor = discount_factor\n        self.epsilon = epsilon\n        \n        # Q-table: state -> action -> value\n        self.q_table = {}\n        \n        # State representation: (vehicles_north, vehicles_east, vehicles_south, vehicles_west, current_green_direction, emergency_present)\n        self.state_size = 6\n        self.action_size = len(ActionType)\n        \n        # Metrics\n        self.total_reward = 0\n        self.episode_count = 0\n        \n    def get_state(self, vehicle_counts: Dict, current_green_direction: int, emergency_present: bool) -> Tuple:\n        \"\"\"\n        Convert environment state to a tuple for Q-table indexing\n        \n        Args:\n            vehicle_counts: Dictionary with vehicle counts per direction\n            current_green_direction: Current direction with green light (0-3)\n            emergency_present: Boolean indicating if emergency vehicle is present\n            \n        Returns:\n            State tuple for Q-table lookup\n        \"\"\"\n        # Discretize vehicle counts into bins\n        def discretize_count(count):\n            if count == 0:\n                return 0\n            elif count <= 3:\n                return 1\n            elif count <= 6:\n                return 2\n            else:\n                return 3\n        \n        state = (\n            discretize_count(vehicle_counts.get('north', 0)),\n            discretize_count(vehicle_counts.get('east', 0)),\n            discretize_count(vehicle_counts.get('south', 0)),\n            discretize_count(vehicle_counts.get('west', 0)),\n            current_green_direction,\n            int(emergency_present)\n        )\n        \n        return state\n    \n    def get_action(self, state: Tuple) -> ActionType:\n        \"\"\"\n        Select action using epsilon-greedy policy\n        \n        Args:\n            state: Current state tuple\n            \n        Returns:\n            Selected action\n        \"\"\"\n        if state not in self.q_table:\n            self.q_table[state] = np.zeros(self.action_size)\n        \n        # Epsilon-greedy action selection\n        if random.random() < self.epsilon:\n            return ActionType(random.randint(0, self.action_size - 1))\n        else:\n            action_values = self.q_table[state]\n            return ActionType(np.argmax(action_values))\n    \n    def calculate_reward(self, vehicle_counts: Dict, waiting_times: Dict, emergency_served: bool) -> float:\n        \"\"\"\n        Calculate reward based on traffic efficiency metrics\n        \n        Args:\n            vehicle_counts: Current vehicle counts per direction\n            waiting_times: Average waiting times per direction\n            emergency_served: Whether emergency vehicle was served promptly\n            \n        Returns:\n            Calculated reward\n        \"\"\"\n        # Base reward components\n        total_vehicles = sum(vehicle_counts.values())\n        avg_waiting_time = float(np.mean(list(waiting_times.values()))) if waiting_times else 0.0\n        \n        # Reward calculation\n        reward = 0\n        \n        # Negative reward for high total vehicles (encourages flow)\n        reward -= total_vehicles * 0.1\n        \n        # Negative reward for high waiting times\n        reward -= avg_waiting_time * 0.05\n        \n        # High positive reward for serving emergency vehicles\n        if emergency_served:\n            reward += 10\n        \n        # Bonus for balanced traffic (penalize if one direction has too many cars)\n        if total_vehicles > 0:\n            max_count = max(vehicle_counts.values())\n            if max_count > total_vehicles * 0.6:  # More than 60% in one direction\n                reward -= 2\n        \n        return reward\n    \n    def update_q_table(self, state: Tuple, action: ActionType, reward: float, next_state: Tuple):\n        \"\"\"\n        Update Q-table using Q-learning update rule\n        \n        Args:\n            state: Previous state\n            action: Action taken\n            reward: Reward received\n            next_state: Resulting state\n        \"\"\"\n        if state not in self.q_table:\n            self.q_table[state] = np.zeros(self.action_size)\n        if next_state not in self.q_table:\n            self.q_table[next_state] = np.zeros(self.action_size)\n        \n        # Q-learning update\n        current_q = self.q_table[state][action.value]\n        max_next_q = np.max(self.q_table[next_state])\n        \n        new_q = current_q + self.learning_rate * (\n            reward + self.discount_factor * max_next_q - current_q\n        )\n        \n        self.q_table[state][action.value] = new_q\n        self.total_reward += reward\n    \n    def decay_epsilon(self, decay_rate=0.995):\n        \"\"\"Decay exploration rate over time\"\"\"\n        self.epsilon = max(0.01, self.epsilon * decay_rate)\n    \n    def get_optimal_timing(self, vehicle_counts: Dict, current_direction: int) -> int:\n        \"\"\"\n        Get optimal green light duration based on learned policy\n        \n        Args:\n            vehicle_counts: Current vehicle counts\n            current_direction: Current green direction\n            \n        Returns:\n            Optimal green duration in milliseconds\n        \"\"\"\n        state = self.get_state(vehicle_counts, current_direction, False)\n        \n        if state not in self.q_table:\n            # Default timing if no learned experience\n            return max(3000, min(8000, vehicle_counts.get(f'direction_{current_direction}', 0) * 1000))\n        \n        # Use learned Q-values to determine timing\n        q_values = self.q_table[state]\n        \n        # If extending green has high value, increase duration\n        if q_values[ActionType.EXTEND_GREEN.value] > q_values[ActionType.SWITCH_TO_YELLOW.value]:\n            base_duration = 5000\n            vehicle_count = sum(vehicle_counts.values())\n            return min(10000, base_duration + vehicle_count * 500)\n        else:\n            return 3000  # Minimum green duration\n    \n    def save_model(self, filepath: str):\n        \"\"\"Save the Q-table to a file\"\"\"\n        import pickle\n        with open(filepath, 'wb') as f:\n            pickle.dump({\n                'q_table': self.q_table,\n                'total_reward': self.total_reward,\n                'episode_count': self.episode_count,\n                'epsilon': self.epsilon\n            }, f)\n    \n    def load_model(self, filepath: str):\n        \"\"\"Load the Q-table from a file\"\"\"\n        import pickle\n        try:\n            with open(filepath, 'rb') as f:\n                data = pickle.load(f)\n                self.q_table = data['q_table']\n                self.total_reward = data['total_reward']\n                self.episode_count = data['episode_count']\n                self.epsilon = data['epsilon']\n            return True\n        except FileNotFoundError:\n            print(f\"Model file {filepath} not found. Starting with fresh Q-table.\")\n            return False\n    \n    def get_statistics(self) -> Dict:\n        \"\"\"Get learning statistics\"\"\"\n        return {\n            'total_reward': self.total_reward,\n            'episode_count': self.episode_count,\n            'epsilon': self.epsilon,\n            'q_table_size': len(self.q_table),\n            'avg_reward_per_episode': self.total_reward / max(1, self.episode_count)\n        }\n\n# Example usage and integration functions\ndef create_smart_traffic_controller():\n    \"\"\"Factory function to create a configured RL agent\"\"\"\n    agent = TrafficRLAgent(\n        learning_rate=0.15,\n        discount_factor=0.9,\n        epsilon=0.2\n    )\n    \n    # Try to load existing model\n    agent.load_model('models/checkpoints/traffic_rl_model.pkl')\n    \n    return agent\n\ndef simulate_training_episode(agent: TrafficRLAgent, steps=1000):\n    \"\"\"\n    Simulate a training episode for the RL agent\n    This would normally be integrated with the actual traffic simulation\n    \"\"\"\n    total_reward = 0\n    \n    for step in range(steps):\n        # Simulate random traffic state\n        vehicle_counts = {\n            'north': random.randint(0, 10),\n            'east': random.randint(0, 10),\n            'south': random.randint(0, 10),\n            'west': random.randint(0, 10)\n        }\n        \n        current_green = random.randint(0, 3)\n        emergency_present = random.random() < 0.05\n        \n        # Get state and action\n        state = agent.get_state(vehicle_counts, current_green, emergency_present)\n        action = agent.get_action(state)\n        \n        # Simulate environment response\n        waiting_times = {dir: random.uniform(5, 30) for dir in ['north', 'east', 'south', 'west']}\n        reward = agent.calculate_reward(vehicle_counts, waiting_times, emergency_present and action == ActionType.EMERGENCY_OVERRIDE)\n        \n        # Simulate next state\n        next_vehicle_counts = {k: max(0, v + random.randint(-2, 3)) for k, v in vehicle_counts.items()}\n        next_state = agent.get_state(next_vehicle_counts, (current_green + 1) % 4, False)\n        \n        # Update Q-table\n        agent.update_q_table(state, action, reward, next_state)\n        total_reward += reward\n    \n    agent.episode_count += 1\n    agent.decay_epsilon()\n    \n    return total_reward","size_bytes":9924},"docs/DESIGN.md":{"content":"# Smart Traffic Management Simulation - Design Document\n\n## Project Overview\nSmart Traffic Management Simulation is a comprehensive system designed for the Smart India Hackathon. It demonstrates intelligent traffic control using AI and machine learning techniques.\n\n## System Architecture\n\n### Frontend\n- **Web Simulation** (`frontend/web_sim/`): HTML/JS Canvas-based visualization\n- **Interactive Dashboard**: Real-time traffic monitoring and control interface\n\n### Backend\n- **Flask Application** (`backend/flask_app/`): Main server application\n- **RL Agent** (`backend/flask_app/rl_agent.py`): Reinforcement learning traffic controller\n- **Pygame Simulation**: Python-based traffic simulation with dynamic lighting\n\n### Models\n- **YOLOv8** (`models/yolov8/`): Vehicle detection and classification\n- **Checkpoints** (`models/checkpoints/`): Trained model artifacts\n\n### Hardware Prototype\n- **Arduino Controller** (`prototype/arduino/`): Physical traffic light controller\n- **Raspberry Pi Reader** (`prototype/raspberry_pi/`): Camera-based vehicle detection\n\n## Key Features\n\n### Intelligent Traffic Control\n- Dynamic traffic light timing based on vehicle density\n- Emergency vehicle priority system\n- Real-time traffic flow optimization\n\n### AI/ML Components\n- Computer vision for vehicle detection\n- Reinforcement learning for optimal traffic control\n- Predictive traffic flow analysis\n\n### Real-time Monitoring\n- Live traffic density visualization\n- Performance metrics and analytics\n- Emergency response coordination\n\n## Technology Stack\n- **Frontend**: HTML5, CSS3, JavaScript (Canvas API)\n- **Backend**: Python (Flask), Node.js (Express)\n- **Simulation**: Python (Pygame, NumPy)\n- **AI/ML**: PyTorch, OpenCV, YOLOv8\n- **Hardware**: Arduino, Raspberry Pi\n\n## Development Phases\n1. **Phase 1**: Basic traffic simulation and web interface\n2. **Phase 2**: AI integration and smart control algorithms\n3. **Phase 3**: Hardware prototype and real-world testing\n4. **Phase 4**: Performance optimization and deployment\n\n## Performance Metrics\n- Average vehicle wait time\n- Traffic throughput efficiency\n- Emergency response time\n- System reliability and uptime","size_bytes":2159},"docs/PROMPTS.md":{"content":"# Development Prompts\n\n## Prompt #1\n**Initial Project Setup**\n\"This is a fresh clone of a GitHub import. Lets make it run in the Replit environment. Explore the codebase and understand its core setup (build system, package installer, languages, project layout, etc). Where possible, try to follow existing project setup, databases, APIs, configuration, etc. Make sure both code and config are working.\"\n\n## Prompt #2\n**Project Structure and Pygame Simulation**\n\"smart-traffic-sim/\n├─ README.md\n├─ LICENSE\n├─ .gitignore\n├─ docs/\n│  ├─ DESIGN.md\n│  └─ PROMPTS.md       <-- store every prompt here (numbered)\n├─ frontend/\n│  └─ web_sim/          <-- HTML/JS Canvas simulation\n│     ├─ index.html\n│     ├─ style.css\n│     └─ app.js\n├─ backend/\n│  ├─ flask_app/\n│  │  ├─ app.py\n│  │  └─ rl_agent.py\n├─ models/\n│  ├─ yolov8/\n│  └─ checkpoints/      <-- store small artifacts or links to HF hub\n├─ notebooks/\n│  └─ train_detector.ipynb\n├─ prototype/\n│  ├─ arduino/\n│  │  └─ traffic_controller.ino\n│  └─ raspberry_pi/\n│     └─ pi_reader.py\n├─ demo_video.mp4\n└─ tests/\n\nTHIS MUST BE THE file pathways please....we can add more to this in the future for now chatgpt gave this...\n\nand first : Build me a Python simulation using Pygame that demonstrates a smart AI traffic light system.\n- There should be 4 lanes (like a crossroad) with moving cars represented as rectangles.\n- Each lane should have a traffic signal (red, yellow, green).\n- Cars should stop when the light is red and move when it is green.\n- Green light duration should be dynamic: based on vehicle count in each lane (randomly generated).\n- Add an \"emergency vehicle\" feature: if an ambulance appears in a lane, the light should immediately switch to green for that lane.\n- Show real-time updates: vehicle count, current green lane, and timer countdown on the screen.\"","size_bytes":1970},"frontend/web_sim/app.js":{"content":"class TrafficSimulation {\n    constructor() {\n        this.isRunning = false;\n        this.simulationInterval = null;\n        this.canvas = document.getElementById('trafficCanvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.intersections = [];\n        this.vehicles = [];\n        \n        this.initializeEventListeners();\n        this.initializeCanvas();\n        this.addLog('Traffic simulation system initialized');\n    }\n\n    initializeEventListeners() {\n        document.getElementById('startBtn').addEventListener('click', () => this.startSimulation());\n        document.getElementById('stopBtn').addEventListener('click', () => this.stopSimulation());\n        document.getElementById('resetBtn').addEventListener('click', () => this.resetSimulation());\n    }\n\n    initializeCanvas() {\n        // Set up canvas for high DPI displays\n        const dpr = window.devicePixelRatio || 1;\n        const rect = this.canvas.getBoundingClientRect();\n        this.canvas.width = rect.width * dpr;\n        this.canvas.height = rect.height * dpr;\n        this.ctx.scale(dpr, dpr);\n        this.canvas.style.width = rect.width + 'px';\n        this.canvas.style.height = rect.height + 'px';\n        \n        this.drawInitialCanvas();\n    }\n\n    drawInitialCanvas() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Draw road grid\n        this.ctx.strokeStyle = '#666';\n        this.ctx.lineWidth = 8;\n        \n        // Horizontal roads\n        for (let i = 1; i <= 3; i++) {\n            const y = (this.canvas.height / 4) * i;\n            this.ctx.beginPath();\n            this.ctx.moveTo(0, y);\n            this.ctx.lineTo(this.canvas.width, y);\n            this.ctx.stroke();\n        }\n        \n        // Vertical roads\n        for (let i = 1; i <= 3; i++) {\n            const x = (this.canvas.width / 4) * i;\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, 0);\n            this.ctx.lineTo(x, this.canvas.height);\n            this.ctx.stroke();\n        }\n        \n        // Draw intersections\n        this.ctx.fillStyle = '#ff6b6b';\n        for (let i = 1; i <= 3; i++) {\n            for (let j = 1; j <= 3; j++) {\n                const x = (this.canvas.width / 4) * i;\n                const y = (this.canvas.height / 4) * j;\n                this.ctx.beginPath();\n                this.ctx.arc(x, y, 15, 0, Math.PI * 2);\n                this.ctx.fill();\n            }\n        }\n        \n        // Add title\n        this.ctx.fillStyle = '#333';\n        this.ctx.font = '16px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('Traffic Network Visualization', this.canvas.width / 2, 30);\n    }\n\n    async fetchTrafficData() {\n        try {\n            const response = await fetch('/api/traffic-data');\n            const data = await response.json();\n            return data;\n        } catch (error) {\n            this.addLog(`Error fetching traffic data: ${error.message}`, 'error');\n            return null;\n        }\n    }\n\n    updateIntersections(trafficData) {\n        if (!trafficData) return;\n        \n        this.intersections = trafficData.intersections;\n        const container = document.getElementById('intersections');\n        container.innerHTML = '';\n        \n        trafficData.intersections.forEach(intersection => {\n            const card = document.createElement('div');\n            card.className = `intersection-card ${intersection.status}`;\n            \n            card.innerHTML = `\n                <div class=\"intersection-name\">${intersection.name}</div>\n                <div class=\"intersection-stats\">\n                    <span>🚗 Vehicles: ${intersection.vehicles}</span>\n                    <span>⏱️ Wait: ${intersection.avgWaitTime}s</span>\n                </div>\n                <div class=\"status-indicator status-${intersection.status}\">\n                    ${intersection.status}\n                </div>\n            `;\n            \n            container.appendChild(card);\n        });\n    }\n\n    updateStats(trafficData) {\n        if (!trafficData) return;\n        \n        const totalVehicles = trafficData.intersections.reduce((sum, int) => sum + int.vehicles, 0);\n        const avgWaitTime = Math.round(\n            trafficData.intersections.reduce((sum, int) => sum + int.avgWaitTime, 0) / \n            trafficData.intersections.length\n        );\n        const congestedAreas = trafficData.intersections.filter(int => int.status === 'congested').length;\n        \n        document.getElementById('totalVehicles').textContent = totalVehicles;\n        document.getElementById('avgWaitTime').textContent = `${avgWaitTime}s`;\n        document.getElementById('congestedAreas').textContent = congestedAreas;\n    }\n\n    drawVehicles() {\n        // Simulate vehicle movement on canvas\n        this.drawInitialCanvas();\n        \n        // Draw moving vehicles\n        this.ctx.fillStyle = '#4CAF50';\n        for (let i = 0; i < this.intersections.length; i++) {\n            const intersection = this.intersections[i];\n            if (!intersection) continue;\n            \n            const baseX = (this.canvas.width / 4) * (i + 1);\n            const baseY = (this.canvas.height / 4) * (i + 1);\n            \n            // Draw vehicles around intersection\n            for (let v = 0; v < Math.min(intersection.vehicles, 8); v++) {\n                const angle = (v / 8) * Math.PI * 2;\n                const radius = 30 + (v * 5);\n                const x = baseX + Math.cos(angle) * radius;\n                const y = baseY + Math.sin(angle) * radius;\n                \n                this.ctx.fillStyle = intersection.status === 'congested' ? '#ff6b6b' : '#4CAF50';\n                this.ctx.beginPath();\n                this.ctx.arc(x, y, 4, 0, Math.PI * 2);\n                this.ctx.fill();\n            }\n        }\n    }\n\n    addLog(message, type = 'info') {\n        const logContainer = document.getElementById('logContainer');\n        const timestamp = new Date().toLocaleTimeString();\n        const logEntry = document.createElement('p');\n        \n        let prefix = '';\n        switch (type) {\n            case 'error':\n                prefix = '❌ ERROR';\n                break;\n            case 'warning':\n                prefix = '⚠️ WARN';\n                break;\n            case 'success':\n                prefix = '✅ SUCCESS';\n                break;\n            default:\n                prefix = 'ℹ️ INFO';\n        }\n        \n        logEntry.textContent = `[${timestamp}] ${prefix}: ${message}`;\n        logContainer.appendChild(logEntry);\n        logContainer.scrollTop = logContainer.scrollHeight;\n        \n        // Keep only last 20 log entries\n        while (logContainer.children.length > 20) {\n            logContainer.removeChild(logContainer.firstChild);\n        }\n    }\n\n    async startSimulation() {\n        if (this.isRunning) return;\n        \n        this.isRunning = true;\n        document.getElementById('startBtn').disabled = true;\n        document.getElementById('stopBtn').disabled = false;\n        \n        this.addLog('Starting traffic simulation...', 'success');\n        \n        this.simulationInterval = setInterval(async () => {\n            const trafficData = await this.fetchTrafficData();\n            if (trafficData) {\n                this.updateIntersections(trafficData);\n                this.updateStats(trafficData);\n                this.drawVehicles();\n                \n                // Log significant events\n                const congestedIntersections = trafficData.intersections.filter(int => int.status === 'congested');\n                if (congestedIntersections.length > 0) {\n                    this.addLog(`Congestion detected at ${congestedIntersections.length} intersection(s)`, 'warning');\n                }\n            }\n        }, 2000);\n    }\n\n    stopSimulation() {\n        if (!this.isRunning) return;\n        \n        this.isRunning = false;\n        document.getElementById('startBtn').disabled = false;\n        document.getElementById('stopBtn').disabled = true;\n        \n        if (this.simulationInterval) {\n            clearInterval(this.simulationInterval);\n            this.simulationInterval = null;\n        }\n        \n        this.addLog('Traffic simulation stopped', 'info');\n    }\n\n    resetSimulation() {\n        this.stopSimulation();\n        \n        // Reset all displays\n        document.getElementById('totalVehicles').textContent = '0';\n        document.getElementById('avgWaitTime').textContent = '0s';\n        document.getElementById('congestedAreas').textContent = '0';\n        \n        // Clear intersections\n        document.getElementById('intersections').innerHTML = '';\n        \n        // Reset canvas\n        this.drawInitialCanvas();\n        \n        // Clear logs except initialization\n        document.getElementById('logContainer').innerHTML = '<p>System reset. Ready to start simulation.</p>';\n        \n        this.addLog('System reset completed', 'success');\n    }\n}\n\n// Initialize the simulation when page loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new TrafficSimulation();\n});","size_bytes":9147},"frontend/web_sim/styles.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    color: #333;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 20px;\n}\n\nheader {\n    text-align: center;\n    margin-bottom: 30px;\n    color: white;\n}\n\nheader h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);\n}\n\nheader p {\n    font-size: 1.1rem;\n    opacity: 0.9;\n}\n\n.dashboard {\n    background: white;\n    border-radius: 15px;\n    padding: 30px;\n    box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n}\n\n.controls {\n    display: flex;\n    gap: 15px;\n    margin-bottom: 30px;\n    justify-content: center;\n}\n\n.btn {\n    padding: 12px 24px;\n    border: none;\n    border-radius: 8px;\n    font-size: 1rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #4CAF50;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #45a049;\n    transform: translateY(-2px);\n}\n\n.btn-secondary {\n    background: #f44336;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #da190b;\n    transform: translateY(-2px);\n}\n\n.btn-tertiary {\n    background: #2196F3;\n    color: white;\n}\n\n.btn-tertiary:hover:not(:disabled) {\n    background: #0b7dda;\n    transform: translateY(-2px);\n}\n\n.btn:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n.stats-overview {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 30px;\n}\n\n.stat-card {\n    background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);\n    padding: 20px;\n    border-radius: 10px;\n    text-align: center;\n    border: 2px solid #e0e0e0;\n}\n\n.stat-card h3 {\n    font-size: 0.9rem;\n    color: #666;\n    margin-bottom: 10px;\n    text-transform: uppercase;\n    letter-spacing: 1px;\n}\n\n.stat-card span {\n    font-size: 2rem;\n    font-weight: bold;\n    color: #333;\n}\n\n.traffic-grid {\n    margin-bottom: 30px;\n}\n\n.traffic-grid h2 {\n    margin-bottom: 20px;\n    color: #333;\n}\n\n.intersections-container {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 20px;\n}\n\n.intersection-card {\n    background: #f8f9fa;\n    border: 2px solid #e9ecef;\n    border-radius: 10px;\n    padding: 20px;\n    transition: all 0.3s ease;\n}\n\n.intersection-card:hover {\n    transform: translateY(-3px);\n    box-shadow: 0 5px 15px rgba(0,0,0,0.1);\n}\n\n.intersection-card.congested {\n    border-color: #dc3545;\n    background: #fff5f5;\n}\n\n.intersection-card.normal {\n    border-color: #28a745;\n    background: #f8fff9;\n}\n\n.intersection-name {\n    font-size: 1.2rem;\n    font-weight: bold;\n    margin-bottom: 15px;\n    color: #333;\n}\n\n.intersection-stats {\n    display: flex;\n    justify-content: space-between;\n    margin-bottom: 10px;\n}\n\n.intersection-stats span {\n    font-size: 0.9rem;\n    color: #666;\n}\n\n.status-indicator {\n    display: inline-block;\n    padding: 4px 12px;\n    border-radius: 20px;\n    font-size: 0.8rem;\n    font-weight: bold;\n    text-transform: uppercase;\n}\n\n.status-normal {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-congested {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n.simulation-area {\n    margin-bottom: 30px;\n}\n\n.simulation-area h2 {\n    margin-bottom: 20px;\n    color: #333;\n}\n\n#trafficCanvas {\n    border: 2px solid #ddd;\n    border-radius: 10px;\n    background: #f8f9fa;\n    display: block;\n    margin: 0 auto;\n    max-width: 100%;\n}\n\n.logs {\n    background: #f8f9fa;\n    border-radius: 10px;\n    padding: 20px;\n}\n\n.logs h3 {\n    margin-bottom: 15px;\n    color: #333;\n}\n\n.log-container {\n    background: #2c3e50;\n    color: #ecf0f1;\n    padding: 15px;\n    border-radius: 5px;\n    font-family: 'Courier New', monospace;\n    font-size: 0.9rem;\n    max-height: 200px;\n    overflow-y: auto;\n}\n\n.log-container p {\n    margin-bottom: 5px;\n    padding: 2px 0;\n}\n\n.log-container p:last-child {\n    margin-bottom: 0;\n}\n\n@media (max-width: 768px) {\n    .container {\n        padding: 10px;\n    }\n    \n    header h1 {\n        font-size: 2rem;\n    }\n    \n    .controls {\n        flex-direction: column;\n        align-items: center;\n    }\n    \n    .btn {\n        width: 200px;\n    }\n    \n    #trafficCanvas {\n        width: 100%;\n        height: auto;\n    }\n}","size_bytes":4409},"prototype/raspberry_pi/pi_reader.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRaspberry Pi Vehicle Detection Script\nUses camera input to detect vehicles and send data to traffic control system\n\"\"\"\n\nimport cv2\nimport numpy as np\nimport time\nimport json\nimport requests\nfrom datetime import datetime\nimport threading\nimport queue\n\nclass VehicleDetector:\n    def __init__(self, camera_id=0):\n        \"\"\"Initialize the vehicle detector with camera\"\"\"\n        self.camera_id = camera_id\n        self.cap = None\n        self.background_subtractor = cv2.createBackgroundSubtractorMOG2(\n            detectShadows=True, varThreshold=100\n        )\n        self.min_area = 500  # Minimum area for vehicle detection\n        self.vehicle_count = 0\n        self.last_count_time = time.time()\n        \n        # Detection zones (define 4 lanes)\n        self.detection_zones = {\n            'north': {'x': 200, 'y': 50, 'w': 100, 'h': 150},\n            'east': {'x': 350, 'y': 200, 'w': 150, 'h': 100},\n            'south': {'x': 200, 'y': 350, 'w': 100, 'h': 150},\n            'west': {'x': 50, 'y': 200, 'w': 150, 'h': 100}\n        }\n        \n        self.vehicle_counts = {'north': 0, 'east': 0, 'south': 0, 'west': 0}\n        \n    def initialize_camera(self):\n        \"\"\"Initialize camera capture\"\"\"\n        try:\n            self.cap = cv2.VideoCapture(self.camera_id)\n            if not self.cap.isOpened():\n                print(f\"Error: Could not open camera {self.camera_id}\")\n                return False\n            \n            # Set camera properties\n            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\n            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n            self.cap.set(cv2.CAP_PROP_FPS, 30)\n            \n            print(\"Camera initialized successfully\")\n            return True\n        except Exception as e:\n            print(f\"Camera initialization error: {e}\")\n            return False\n    \n    def detect_vehicles_in_zone(self, frame, zone_name, zone):\n        \"\"\"Detect vehicles in a specific zone\"\"\"\n        x, y, w, h = zone['x'], zone['y'], zone['w'], zone['h']\n        \n        # Extract region of interest\n        roi = frame[y:y+h, x:x+w]\n        \n        # Apply background subtraction\n        fg_mask = self.background_subtractor.apply(roi)\n        \n        # Morphological operations to clean up the mask\n        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n        fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_OPEN, kernel)\n        \n        # Find contours\n        contours, _ = cv2.findContours(fg_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        \n        vehicle_count = 0\n        for contour in contours:\n            area = cv2.contourArea(contour)\n            if area > self.min_area:\n                vehicle_count += 1\n                \n                # Draw bounding box on original frame\n                x_c, y_c, w_c, h_c = cv2.boundingRect(contour)\n                cv2.rectangle(frame, (x + x_c, y + y_c), (x + x_c + w_c, y + y_c + h_c), (0, 255, 0), 2)\n        \n        return vehicle_count\n    \n    def process_frame(self, frame):\n        \"\"\"Process a single frame for vehicle detection\"\"\"\n        if frame is None:\n            return None\n        \n        # Draw detection zones\n        for zone_name, zone in self.detection_zones.items():\n            x, y, w, h = zone['x'], zone['y'], zone['w'], zone['h']\n            cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 2)\n            cv2.putText(frame, zone_name.upper(), (x, y - 10), \n                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 0, 0), 2)\n        \n        # Detect vehicles in each zone\n        for zone_name, zone in self.detection_zones.items():\n            count = self.detect_vehicles_in_zone(frame, zone_name, zone)\n            self.vehicle_counts[zone_name] = count\n            \n            # Display count on frame\n            x, y = zone['x'], zone['y']\n            cv2.putText(frame, f\"Vehicles: {count}\", (x, y + zone['h'] + 20), \n                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)\n        \n        # Display total statistics\n        total_vehicles = sum(self.vehicle_counts.values())\n        cv2.putText(frame, f\"Total Vehicles: {total_vehicles}\", (10, 30), \n                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)\n        \n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        cv2.putText(frame, timestamp, (10, frame.shape[0] - 10), \n                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)\n        \n        return frame\n    \n    def send_data_to_server(self, server_url=\"http://localhost:5000/api/vehicle-data\"):\n        \"\"\"Send vehicle count data to traffic control server\"\"\"\n        data = {\n            'timestamp': datetime.now().isoformat(),\n            'vehicle_counts': self.vehicle_counts,\n            'total_vehicles': sum(self.vehicle_counts.values())\n        }\n        \n        try:\n            response = requests.post(server_url, json=data, timeout=5)\n            if response.status_code == 200:\n                print(f\"Data sent successfully: {self.vehicle_counts}\")\n            else:\n                print(f\"Server error: {response.status_code}\")\n        except requests.exceptions.RequestException as e:\n            print(f\"Failed to send data: {e}\")\n    \n    def run_detection(self, display=True, send_data=True):\n        \"\"\"Main detection loop\"\"\"\n        if not self.initialize_camera():\n            return\n        \n        print(\"Starting vehicle detection...\")\n        print(\"Press 'q' to quit, 's' to save current frame\")\n        \n        frame_count = 0\n        last_data_send = time.time()\n        \n        try:\n            while True:\n                ret, frame = self.cap.read()\n                if not ret:\n                    print(\"Failed to read frame\")\n                    break\n                \n                # Process frame\n                processed_frame = self.process_frame(frame)\n                \n                if display and processed_frame is not None:\n                    cv2.imshow('Vehicle Detection', processed_frame)\n                \n                # Send data every 2 seconds\n                if send_data and time.time() - last_data_send >= 2.0:\n                    threading.Thread(target=self.send_data_to_server, daemon=True).start()\n                    last_data_send = time.time()\n                \n                frame_count += 1\n                \n                # Handle keyboard input\n                key = cv2.waitKey(1) & 0xFF\n                if key == ord('q'):\n                    break\n                elif key == ord('s'):\n                    filename = f\"traffic_frame_{int(time.time())}.jpg\"\n                    cv2.imwrite(filename, processed_frame)\n                    print(f\"Frame saved as {filename}\")\n                \n        except KeyboardInterrupt:\n            print(\"\\nDetection stopped by user\")\n        \n        finally:\n            self.cleanup()\n    \n    def cleanup(self):\n        \"\"\"Clean up resources\"\"\"\n        if self.cap:\n            self.cap.release()\n        cv2.destroyAllWindows()\n        print(\"Resources cleaned up\")\n\ndef main():\n    \"\"\"Main function\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='Vehicle Detection for Smart Traffic Management')\n    parser.add_argument('--camera', type=int, default=0, help='Camera ID (default: 0)')\n    parser.add_argument('--no-display', action='store_true', help='Run without display (headless)')\n    parser.add_argument('--no-server', action='store_true', help='Don\\'t send data to server')\n    parser.add_argument('--server-url', type=str, default='http://localhost:5000/api/vehicle-data',\n                       help='Server URL for sending data')\n    \n    args = parser.parse_args()\n    \n    detector = VehicleDetector(camera_id=args.camera)\n    detector.run_detection(\n        display=not args.no_display,\n        send_data=not args.no_server\n    )\n\nif __name__ == \"__main__\":\n    main()","size_bytes":7926},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"numpy>=2.3.3\",\n    \"pygame>=2.6.1\",\n]\n","size_bytes":185},"server.js":{"content":"const express = require('express');\nconst path = require('path');\n\nconst app = express();\nconst PORT = 5000;\n\n// Middleware to disable caching for development\napp.use((req, res, next) => {\n  res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');\n  res.setHeader('Pragma', 'no-cache');\n  res.setHeader('Expires', '0');\n  next();\n});\n\n// Serve static files from frontend/web_sim\napp.use(express.static(path.join(__dirname, 'frontend', 'web_sim')));\n\n// API endpoint for traffic data simulation\napp.get('/api/traffic-data', (req, res) => {\n  // Simulate traffic data\n  const trafficData = {\n    intersections: [\n      {\n        id: 1,\n        name: 'Main St & 1st Ave',\n        vehicles: Math.floor(Math.random() * 20) + 5,\n        avgWaitTime: Math.floor(Math.random() * 30) + 10,\n        status: Math.random() > 0.7 ? 'congested' : 'normal'\n      },\n      {\n        id: 2,\n        name: 'Oak Rd & 2nd Ave',\n        vehicles: Math.floor(Math.random() * 15) + 3,\n        avgWaitTime: Math.floor(Math.random() * 25) + 8,\n        status: Math.random() > 0.8 ? 'congested' : 'normal'\n      },\n      {\n        id: 3,\n        name: 'Pine St & 3rd Ave',\n        vehicles: Math.floor(Math.random() * 18) + 7,\n        avgWaitTime: Math.floor(Math.random() * 35) + 12,\n        status: Math.random() > 0.6 ? 'congested' : 'normal'\n      }\n    ],\n    timestamp: new Date().toISOString()\n  };\n  \n  res.json(trafficData);\n});\n\n// Catch all handler for SPA\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'frontend', 'web_sim', 'index.html'));\n});\n\napp.listen(PORT, '0.0.0.0', () => {\n  console.log(`Smart Traffic Management Simulation server running on http://0.0.0.0:${PORT}`);\n});","size_bytes":1699},"tests/__init__.py":{"content":"","size_bytes":0}},"version":1}